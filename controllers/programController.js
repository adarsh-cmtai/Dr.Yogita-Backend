const Program = require('../models/Program'); // Adjust path
const cloudinary = require('../config/cloudinary'); // Adjust path
const streamifier = require('streamifier');
const slugify = require('slugify');

// @desc    Get all programs
// @route   GET /api/programs
// @access  Public
exports.getAllPrograms = async (req, res) => {
  try {
    const programs = await Program.find().sort({ createdAt: -1 });
    const formattedPrograms = programs.map(p => ({
        ...p.toObject(),
        thumbnail: p.thumbnailUrl ? { url: p.thumbnailUrl } : undefined
    }));
    res.status(200).json({ success: true, count: formattedPrograms.length, data: formattedPrograms });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Server Error' });
  }
};

// @desc    Get single program by ID
// @route   GET /api/programs/id/:id
// @access  Public
exports.getProgramById = async (req, res) => {
    try {
      console.log("this is program");
      const program = await Program.findById(req.params.id);
      if (!program) {
        return res.status(404).json({ success: false, error: 'Program not found' });
      }
      res.status(200).json({ success: true, data: program }); // Send raw data
    } catch (error) {
      console.error("Error fetching program by ID:", error);
      if (error.kind === 'ObjectId') {
          return res.status(404).json({ success: false, error: 'Program not found (invalid ID format)' });
      }
      res.status(500).json({ success: false, error: 'Server Error' });
    }
};

// @desc    Get single program by slug
// @route   GET /api/programs/:slug
// @access  Public
exports.getProgramBySlug = async (req, res) => {
  try {
    const program = await Program.findOne({ slug: req.params.slug });
    if (!program) {
      return res.status(404).json({ success: false, error: 'Program not found' });
    }
    res.status(200).json({ success: true, data: program });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Server Error' });
  }
};

// @desc    Create a new program
// @route   POST /api/programs
// @access  Private
exports.createProgram = async (req, res) => {
  try {
    const { title, description, price, duration, youtubeLink } = req.body;
    const thumbnailFile = req.files?.thumbnailFile ? req.files.thumbnailFile[0] : null;

    if (!title || !description || !price || !duration) {
        return res.status(400).json({ success: false, error: 'Title, Description, Price, and Duration are required.' });
    }
    if (!thumbnailFile) {
      return res.status(400).json({ success: false, error: 'Thumbnail image is required for new program' });
    }

    const streamUpload = (file) => {
        return new Promise((resolve, reject) => {
            let stream = cloudinary.uploader.upload_stream(
              { folder: "physio_programs" },
              (error, result) => {
                if (result) { resolve(result); } else { reject(error); }
              }
            );
          streamifier.createReadStream(file.buffer).pipe(stream);
        });
    };
    const cloudinaryResult = await streamUpload(thumbnailFile);

    const newProgram = await Program.create({
      title, description, price: Number(price), duration,
      youtubeLink: youtubeLink || '',
      thumbnailUrl: cloudinaryResult.secure_url,
      cloudinaryPublicId: cloudinaryResult.public_id,
      // Slug is auto-generated by Mongoose pre-save hook
    });
    res.status(201).json({ success: true, data: newProgram });
  } catch (error) {
    console.error("Create Program Error:", error);
    if (error.name === 'ValidationError') {
        return res.status(400).json({ success: false, error: Object.values(error.errors).map(val => val.message).join(', ') });
    }
    res.status(500).json({ success: false, error: 'Server Error creating program' });
  }
};

// @desc    Update a program
// @route   PUT /api/programs/:id
// @access  Private
exports.updateProgram = async (req, res) => {
    try {
        let program = await Program.findById(req.params.id);
        if (!program) { return res.status(404).json({ success: false, error: 'Program not found' }); }

        const { title, description, price, duration, youtubeLink, thumbnail: thumbnailUrlFromForm } = req.body;
        const thumbnailFile = req.files?.thumbnailFile ? req.files.thumbnailFile[0] : null;
        
        let updateData = {};
        if (title) updateData.title = title;
        if (description) updateData.description = description;
        if (price !== undefined) updateData.price = Number(price);
        if (duration) updateData.duration = duration;
        if (youtubeLink !== undefined) updateData.youtubeLink = youtubeLink;

        if (thumbnailFile) {
            if (program.cloudinaryPublicId) {
                try { await cloudinary.uploader.destroy(program.cloudinaryPublicId); }
                catch (e) { console.warn("Old cloudinary image delete failed (program update):", e.message); }
            }
            const streamUpload = (file) => { /* ... same streamUpload helper ... */ return new Promise((resolve, reject) => { let stream = cloudinary.uploader.upload_stream( { folder: "physio_programs" }, (error, result) => { if (result) resolve(result); else reject(error); } ); streamifier.createReadStream(file.buffer).pipe(stream); }); };
            const cloudinaryResult = await streamUpload(thumbnailFile);
            updateData.thumbnailUrl = cloudinaryResult.secure_url;
            updateData.cloudinaryPublicId = cloudinaryResult.public_id;
        } else if (thumbnailUrlFromForm && program.thumbnailUrl !== thumbnailUrlFromForm) {
            updateData.thumbnailUrl = thumbnailUrlFromForm; 
        } else if (!thumbnailUrlFromForm && program.thumbnailUrl) { // Explicitly clear
            if (program.cloudinaryPublicId) {
                try { await cloudinary.uploader.destroy(program.cloudinaryPublicId); }
                catch (e) { console.warn("Old cloudinary image delete failed (program update - clear):", e.message); }
                updateData.cloudinaryPublicId = null;
            }
            updateData.thumbnailUrl = null;
        }

        if (title && title !== program.title) { // Slug is handled by pre-save hook
            updateData.slug = slugify(title, { lower: true, strict: true }); // Also explicitly set if model hook doesn't always run on findByIdAndUpdate
        }
        
        const updatedProgram = await Program.findByIdAndUpdate(req.params.id, updateData, { new: true, runValidators: true });
        res.status(200).json({ success: true, data: updatedProgram });
    } catch (error) {
        console.error("Update Program Error:", error);
         if (error.name === 'ValidationError') {
            return res.status(400).json({ success: false, error: Object.values(error.errors).map(val => val.message).join(', ') });
        }
        res.status(500).json({ success: false, error: 'Server Error updating program' });
    }
};

// @desc    Delete a program
// @route   DELETE /api/programs/:id
// @access  Private
exports.deleteProgram = async (req, res) => {
  try {
    const program = await Program.findById(req.params.id);
    if (!program) {
      return res.status(404).json({ success: false, error: 'Program not found' });
    }

    if (program.cloudinaryPublicId) {
      try {await cloudinary.uploader.destroy(program.cloudinaryPublicId); }
      catch(e){console.warn("Cloudinary delete failed for program thumbnail:", e.message)}
    }
    await program.deleteOne();
    res.status(200).json({ success: true, message: 'Program removed successfully' }); // For consistency
  } catch (error) {
    console.error("Delete Program Error:", error);
    res.status(500).json({ success: false, error: 'Server Error' });
  }
};