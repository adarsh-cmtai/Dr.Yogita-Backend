// backend/controllers/podcastSeriesController.js
const PodcastSeries = require('../models/PodcastSeries');
const PodcastEpisode = require('../models/PodcastEpisode'); // To handle episode deletion if series is deleted
const cloudinary = require('../config/cloudinary'); // Assuming this is your Cloudinary config
const streamifier = require('streamifier');
const mongoose = require('mongoose');

// Helper function to upload to Cloudinary
const uploadToCloudinary = (fileBuffer, folder) => {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: folder },
      (error, result) => {
        if (error) reject(error);
        else resolve(result);
      }
    );
    streamifier.createReadStream(fileBuffer).pipe(uploadStream);
  });
};

// @desc    Create a new podcast series
// @route   POST /api/podcast-series
// @access  Private (add auth later)
exports.createPodcastSeries = async (req, res, next) => {
  const { title, description, category, author } = req.body;
  const coverImageFile = req.file; // From multer 'uploadPodcastSeriesCover' middleware

  if (!title || !description) {
    return res.status(400).json({ success: false, error: 'Title and Description are required for a podcast series.' });
  }
  if (!coverImageFile) {
    return res.status(400).json({ success: false, error: 'Cover image is required for a new podcast series.' });
  }

  try {
    const uploadResult = await uploadToCloudinary(coverImageFile.buffer, "podcast_series_covers");
    
    const newSeries = new PodcastSeries({
      title,
      description,
      category,
      author,
      coverImageUrl: uploadResult.secure_url,
      cloudinaryPublicIdCover: uploadResult.public_id,
      // Slug is auto-generated by pre-save hook
    });

    const savedSeries = await newSeries.save();
    res.status(201).json({ success: true, data: savedSeries });
  } catch (error) {
    // If series save fails after image upload, try to delete uploaded image
    if (uploadResult && uploadResult.public_id) {
        try { await cloudinary.uploader.destroy(uploadResult.public_id); }
        catch (e) { console.warn("Cloudinary cleanup failed after series creation error:", e.message); }
    }
    next(error); // Pass to global error handler
  }
};

// @desc    Get all podcast series
// @route   GET /api/podcast-series
// @access  Public
exports.getAllPodcastSeries = async (req, res, next) => {
  try {
    const series = await PodcastSeries.find().sort({ createdAt: -1 });
    res.json({ success: true, count: series.length, data: series });
  } catch (error) {
    next(error);
  }
};

// @desc    Get a single podcast series by ID or Slug
// @route   GET /api/podcast-series/:identifier
// @access  Public
exports.getPodcastSeriesByIdentifier = async (req, res, next) => {
  try {
    const identifier = req.params.identifier;
    let series;

    if (mongoose.Types.ObjectId.isValid(identifier)) {
      series = await PodcastSeries.findById(identifier);
    }
    
    if (!series) { // If not found by ID or if identifier is not an ObjectId, try by slug
      series = await PodcastSeries.findOne({ slug: identifier });
    }

    if (!series) {
      return res.status(404).json({ success: false, error: 'Podcast series not found' });
    }
    res.json({ success: true, data: series });
  } catch (error) {
    next(error);
  }
};

// @desc    Update a podcast series
// @route   PUT /api/podcast-series/:id
// @access  Private (add auth later)
exports.updatePodcastSeries = async (req, res, next) => {
  const { title, description, category, author } = req.body;
  const coverImageFile = req.file; // New cover image if uploaded
  let oldCloudinaryPublicIdCover;

  try {
    let series = await PodcastSeries.findById(req.params.id);
    if (!series) {
      return res.status(404).json({ success: false, error: 'Podcast series not found' });
    }
    oldCloudinaryPublicIdCover = series.cloudinaryPublicIdCover; // Store old ID for potential deletion

    // Update text fields
    if (title) series.title = title;
    if (description) series.description = description;
    if (category) series.category = category;
    if (author) series.author = author;
    // Slug will be updated by pre-save hook if title changes

    let uploadResult;
    if (coverImageFile) {
      uploadResult = await uploadToCloudinary(coverImageFile.buffer, "podcast_series_covers");
      series.coverImageUrl = uploadResult.secure_url;
      series.cloudinaryPublicIdCover = uploadResult.public_id;
    }

    const updatedSeries = await series.save();

    // If update successful and new image uploaded, delete old image from Cloudinary
    if (uploadResult && oldCloudinaryPublicIdCover && oldCloudinaryPublicIdCover !== series.cloudinaryPublicIdCover) {
      try { await cloudinary.uploader.destroy(oldCloudinaryPublicIdCover); }
      catch (e) { console.warn("Old Cloudinary cover image delete failed during series update:", e.message); }
    }
    
    res.json({ success: true, data: updatedSeries });
  } catch (error) {
     // If series save fails after new image upload, try to delete the newly uploaded image
    if (uploadResult && uploadResult.public_id) {
        try { await cloudinary.uploader.destroy(uploadResult.public_id); }
        catch (e) { console.warn("Cloudinary cleanup failed after series update error:", e.message); }
    }
    next(error);
  }
};

// @desc    Delete a podcast series (and its episodes + their thumbnails)
// @route   DELETE /api/podcast-series/:id
// @access  Private (add auth later)
exports.deletePodcastSeries = async (req, res, next) => {
  try {
    const series = await PodcastSeries.findById(req.params.id);
    if (!series) {
      return res.status(404).json({ success: false, error: 'Podcast series not found' });
    }

    // Find all episodes of this series
    const episodes = await PodcastEpisode.find({ podcastSeries: series._id });

    // Delete all episode thumbnails from Cloudinary
    for (const episode of episodes) {
      if (episode.cloudinaryPublicIdThumbnail) {
        try { await cloudinary.uploader.destroy(episode.cloudinaryPublicIdThumbnail); }
        catch (e) { console.warn(`Failed to delete episode thumbnail ${episode.cloudinaryPublicIdThumbnail} from Cloudinary:`, e.message); }
      }
    }

    // Delete all episodes of this series from DB
    await PodcastEpisode.deleteMany({ podcastSeries: series._id });

    // Delete series cover image from Cloudinary
    if (series.cloudinaryPublicIdCover) {
      try { await cloudinary.uploader.destroy(series.cloudinaryPublicIdCover); }
      catch (e) { console.warn(`Failed to delete series cover ${series.cloudinaryPublicIdCover} from Cloudinary:`, e.message); }
    }

    // Delete the series itself
    await series.deleteOne(); // Use deleteOne on the document instance

    res.json({ success: true, message: 'Podcast series and its episodes removed' });
  } catch (error) {
    next(error);
  }
};